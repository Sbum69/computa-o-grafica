<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Chuva Residual</title>
<style>
	body {
		display: flex;
		justify-content: center;
		align-items: center;
		height: 100vh;
		margin: 0;
	}
	canvas {
		border: 3px solid #2e7d32; /* verde */
		background-color: #e0f7fa;
	}
</style>
</head>

<body>
	<canvas id="gameCanvas" width="600" height="400">O seu navegador não suporta Canvas.</canvas>


	<script type="module">
		import { HUD } from "./hud.js";
		import { robo, updateRobo, drawRobo } from "./robot.js";
		import * as Lixos from "./lixos.js";
		// parte principal
		const canvas = document.getElementById("gameCanvas");
		const ctx = canvas.getContext("2d");

	const W = canvas.width;
	const H = canvas.height;

		// lixo
		const chuvaLista = [];
		let spawnTimer = 0;

		// Variáveis para o Game Loop e DeltaTime
		let lastTime = 0;
		let deltaTime = 0;

		function criarLixo() {
			const x = Math.random() * (W - 100);

			const tiposLixo = Object.values(Lixos);
			const LixoClasse = tiposLixo[Math.floor(Math.random() * tiposLixo.length)];

			const obj = new LixoClasse(x);
			chuvaLista.push(obj);
		}

	// ATUALIZADO: Calcula 2 pontos por objeto depositado
	function porNoLixo() {
		const binX = W - 80;
		const binY = H - 100;

		if (robo.x + robo.w > binX && robo.x < binX + 60) {
			let lixoDepositado = 0; // Conta o número de lixos a serem depositados

			for (const obj of chuvaLista) {
				if (obj.onRobot) {
					obj.onRobot = false;
					obj.jumpingToBin = true;
					obj.jumpProgress = 0;
					lixoDepositado++;
				}
			}

			// Adiciona 2 pontos por cada lixo depositado
			if (lixoDepositado > 0) {
				HUD.adicionarPontos(lixoDepositado * 2);
			}
		}
	}


	function render(timestamp) {
		// CÁLCULO DO DELTATIME
		if (!lastTime) lastTime = timestamp;
		deltaTime = (timestamp - lastTime) / 1000; // Tempo em segundos
		lastTime = timestamp;

		// NOVO: Para o jogo se tiver terminado
		if (HUD.jogoTerminado) {
			// Apenas desenha o HUD e espera pelo botão de reiniciar
			HUD.desenhar(ctx);
			// mostrarBotaoReiniciar();
			return;
		}


		// fundo
		ctx.fillStyle = "#b3e5fc";
		ctx.fillRect(0, 0, W, H);

		// chão
		ctx.fillStyle = "#81c784";
		ctx.fillRect(0, H - 40, W, 40);

		// caixote de lixo
		ctx.fillStyle = "#4caf50";
		ctx.fillRect(W - 80, H - 100, 60, 60);

		// cair lixo ocasionalmente
		spawnTimer++;
		if (spawnTimer > 100) {
			criarLixo();
			spawnTimer = 0;
		}

		updateRobo(W);
		drawRobo(ctx);
		porNoLixo();

		// mover e atualizar chuva
		for (let i = chuvaLista.length - 1; i >= 0; i--) {
			const obj = chuvaLista[i];

			obj.update(robo, W - 50, H - 100);
			obj.draw(ctx);

			// NOVO: Verifica se o lixo caiu para fora do ecrã
			if (obj.y + obj.h > H - 40) {

				HUD.perderVida();
				chuvaLista.splice(i, 1); // Remove o lixo
			}
		}

		// quanto mais peso, mais lento o robô
		const totalWeight = chuvaLista
			.filter(o => o.onRobot)
			.reduce((sum, o) => sum + o.weight, 0);
		robo.speed = 6 / (1 + totalWeight * 0.075);

		// remover lixo posto no caixote
		for (let i = chuvaLista.length - 1; i >= 0; i--) {
			if (chuvaLista[i].collected) chuvaLista.splice(i, 1);
		}

		// ATUALIZAÇÃO E DESENHO DO HUD
		HUD.atualizar(deltaTime);
		HUD.desenhar(ctx);

		requestAnimationFrame(render);
	}
	render();
</script>
</body>
</html>